<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Interface for the storage system."><title>calimero_storage::interface - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="calimero_storage" data-themes="" data-resource-suffix="" data-rustdoc-version="1.85.0 (4d91de4e4 2025-02-17)" data-channel="1.85.0" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../../static.files/storage-59e33391.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../calimero_storage/index.html">calimero_<wbr>storage</a><span class="version">0.1.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module interface</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#synchronisation" title="Synchronisation">Synchronisation</a><ul><li><a href="#crdt-model" title="CRDT model">CRDT model</a></li><li><a href="#direct-changes" title="Direct changes">Direct changes</a></li><li><a href="#comparison" title="Comparison">Comparison</a></li></ul></li></ul><h3><a href="#structs">Module Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="../index.html">In crate calimero_<wbr>storage</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../index.html">calimero_storage</a></span><h1>Module <span>interface</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/calimero_storage/interface.rs.html#1-1308">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Interface for the storage system.</p>
<p>This module contains the interface for the storage system, which provides
the basics of loading and saving data, but presents a number of helper
methods and additional functionality to abstract away common operations.</p>
<p>This follows the repository pattern, where the interface is the primary
means of interacting with the storage system, rather than the ActiveRecord
pattern where the model is the primary means of interaction.</p>
<h2 id="synchronisation"><a class="doc-anchor" href="#synchronisation">§</a>Synchronisation</h2>
<p>There are two main mechanisms involved in synchronisation:</p>
<ol>
<li><strong>Direct changes</strong>: When a change is made locally, the resulting
actions need to be propagated to other nodes.</li>
<li><strong>Comparison</strong>: When a comparison is made between two nodes, the
resulting actions need to be taken to bring the nodes into sync.</li>
</ol>
<p>The entry points for synchronisation are therefore either the
<a href="struct.Interface.html#method.apply_action" title="associated function calimero_storage::interface::Interface::apply_action"><code>apply_action()</code></a> method, to carry out actions;
or the <a href="struct.Interface.html#method.compare_trees" title="associated function calimero_storage::interface::Interface::compare_trees"><code>compare_trees()</code></a> method, to compare
two nodes, which will emit actions to pass to <a href="struct.Interface.html#method.apply_action" title="associated function calimero_storage::interface::Interface::apply_action"><code>apply_action()</code></a>
on either the local or remote node, or both.</p>
<h3 id="crdt-model"><a class="doc-anchor" href="#crdt-model">§</a>CRDT model</h3>
<p>Calimero primarily uses operation-based CRDTs, also called commutative
replicated data types (CmRDTs). This means that the order of operations does
not matter, and the outcome will be the same regardless of the order in
which the operations are applied.</p>
<p>It is worth noting that the orthodox CmRDT model does not feature or require
a comparison activity, as there is an operating assumption that all updates
have been carried out fully and reliably.</p>
<p>The alternative CRDT approach is state-based, also called convergent
replicated data types (CvRDTs). This is a comparison-based approach, but the
downside is that this model requires the full state to be transmitted
between nodes, which can be costly. Although this approach is easier to
implement, and fits well with gossip protocols, it is not as efficient as
the operation-based model.</p>
<p>The standard choice therefore comes down to:</p>
<ul>
<li>Use CmRDTs and guarantee that all updates are carried out fully and
reliably, are not dropped or duplicated, and are replayed in causal
order.</li>
<li>Use CvRDTs and accept the additional bandwidth cost of transmitting the
full state for every single CRDT.</li>
</ul>
<p>It does not fit the Calimero objectives to transmit the entire state for
every update, but there is also no guarantee that all updates will be
carried out fully and reliably. Therefore, Calimero uses a hybrid approach
that represents the best of both worlds.</p>
<p>In the first instance, operations are emitted (in the form of <a href="enum.Action.html" title="enum calimero_storage::interface::Action"><code>Action</code></a>s)
whenever a change is made. These operations are then propagated to other
nodes, where they are executed. This is the CmRDT model.</p>
<p>However, there are cases where a node may have missed an update, for
instance, if it was offline. In this case, the node will be out of sync with
the rest of the network. To bring the node back into sync, a comparison is
made between the local node and a remote node, and the resulting actions are
executed. This is the CvRDT model.</p>
<p>The storage system maintains a set of Merkle hashes, which are stored
against each element, and represent the state of the element and its
children. The Merkle hash for an element can therefore be used to trivially
determine whether an element or any of its descendants have changed,
without actually needing to compare every entity in the tree.</p>
<p>Therefore, when a comparison is carried out it is not a full state
comparison, but a comparison of the immediate data and metadata of given
element(s). This is sufficient to determine whether the nodes are in sync,
and to generate the actions needed to bring them into sync. If there is any
deviation detected, the comparison will recurse into the children of the
element(s) in question, and generate further actions as necessary — but this
will only ever examine those descendent entities for which the Merkle hash
differs.</p>
<p>We can therefore summarise this position as being: Calimero uses a CmRDT
model for direct changes, and a CvRDT model for comparison as a fallback
mechanism to bring nodes back into sync when needed.</p>
<h3 id="direct-changes"><a class="doc-anchor" href="#direct-changes">§</a>Direct changes</h3>
<p>When a change is made locally, the resulting actions need to be propagated
to other nodes. An action list will be generated, which can be made up of
<a href="enum.Action.html#variant.Add" title="variant calimero_storage::interface::Action::Add"><code>Add</code></a>, <a href="enum.Action.html#variant.Delete" title="variant calimero_storage::interface::Action::Delete"><code>Delete</code></a>, and <a href="enum.Action.html#variant.Update" title="variant calimero_storage::interface::Action::Update"><code>Update</code></a>
actions. These actions are then propagated to all the other nodes in the
network, where they are executed using the <a href="struct.Interface.html#method.apply_action" title="associated function calimero_storage::interface::Interface::apply_action"><code>apply_action()</code></a>
method.</p>
<p>This is a straightforward process, as the actions are known and are fully
self-contained without any wider impact. Order does not strictly matter, as
the actions are commutative, and the outcome will be the same regardless of
the order in which they are applied. Any conflicts are handled using the
last-write-wins strategy.</p>
<p>There are certain cases where a mis-ordering of action, which is
essentially the same as having missing actions, can result in an invalid
state. For instance, if a child is added before the parent, the parent will
not exist and the child will be orphaned. In this situation we can either
ignore the child, or we can block its addition until the parent has been
added, or we can store it as an orphaned entity to be resolved later. At
present we follow the last approach, as it aligns well with the use of
comparisons to bring nodes back into sync. We therefore know that the node
will <em>eventually</em> become consistent, which is all we guarantee.</p>
<p>TODO: Examine whether this is the right approach, or whether we should for
TODO: instance block and do a comparison on the parent to ensure that local
TODO: state is as consistent as possible.</p>
<p>Providing all generated actions are carried out, all nodes will eventually
be in sync, without any need for comparisons, transmission of full states,
or a transaction model (which requires linear history, and therefore
becomes mathematically unsuitable for large distributed systems).</p>
<h3 id="comparison"><a class="doc-anchor" href="#comparison">§</a>Comparison</h3>
<p>There are a number of situations under which a comparison may be needed:</p>
<ol>
<li>A node has missed an update, and needs to be brought back into sync
(i.e. there is a gap in the instruction set).</li>
<li>A node has been offline, and needs to be brought back into sync (i.e.
all instructions since a certain point have been missed).</li>
<li>A discrepancy has been detected between two nodes, and they need to be
brought back into sync.</li>
</ol>
<p>A comparison is primarily triggered from a catch-up as a proactive measure,
i.e. without knowing if any changes exist, but can also arise at any point
if a discrepancy is detected.</p>
<p>When performing a comparison, the data we have is the result of the entity
being serialised by the remote note, passed to us, and deserialised, so it
should be comparable in structure to having loaded it from the local
database.</p>
<p>We therefore have access to the data and metadata, which includes the
immediate fields of the entity (i.e. the <a href="../entities/trait.AtomicUnit.html" title="trait calimero_storage::entities::AtomicUnit"><code>AtomicUnit</code></a>)
and also a list of the children.</p>
<p>The stored list of children contains their Merkle hashes, thereby allowing
us to check all children in one operation instead of needing to load each
child in turn, as that would require remote data for each child, and that
would not be as efficient.</p>
<ul>
<li>
<p>If a child exists on both sides and the hash is different, we recurse
into a comparison for that child.</p>
</li>
<li>
<p>If a child is missing on one side then we can go with the side that has
the latest parent and add or remove the child.</p>
</li>
</ul>
<p>Notably, in the case of there being a missing child, the resolution
mechanism does expose a small risk of erroneous outcome. For instance, if
the local node has had a child added, and has been offline, and the parent
has been updated remotely — in this situation, in the absence of any other
activity, a comparison (e.g. a catch-up when coming back online) would
result in losing the child, as the remote node would not have the child in
its list of children. This edge case should usually be handled by the
specific add and remove events generated at the time of the original
activity, which should get propagated independently of a sync. However,
there are three extended options that can be implemented:</p>
<ol>
<li>Upon catch-up, any local list of actions can be held and replayed
locally after synchronisation. Alone, this would not correct the
situation, due to last-write-wins rules, but additional logic could be
considered for this particular situation.</li>
<li>During or after performing a comparison, all local children for an
entity can be loaded by path and checked against the parent’s list of
children. If there are any deviations then appropriate action can be
taken. This does not fully cater for the edge case, and again would not
correct the situation on its own, but additional logic could be added.</li>
<li>A special kind of “deleted” element could be added to the system, which
would store metadata for checking. This would be beneficial as it would
allow differentiation between a missing child and a deleted child,
which is the main problem exposed by the edge case. However, although
this represents a full solution from a data mechanism perspective, it
would not be desirable to store deleted entries permanently. It would
be best combined with a cut-off constraint, that would limit the time
period in which a catch-up can be performed, and after which the
deleted entities would be purged. This does add complexity not only in
the effect on the wider system of implementing that constraint, but
also in the need for garbage collection to remove the deleted entities.
This would likely be better conducted the next time the parent entity
is updated, but there are a number of factors to consider here.</li>
<li>Another way to potentially handle situations of this nature is to
combine multiple granular updates into an atomic group operation that
ensures that all updates are applied together. However, this remains to
be explored, as it may not fit with the wider system design.</li>
</ol>
<p>Due to the potential complexity, this edge case is not currently mitigated,
but will be the focus of future development.</p>
<p>TODO: Assess the best approach for handling this edge case in a way that
TODO: fits with the wider system design, and add extended tests for it.</p>
<p>The outcome of a comparison is that the calling code receives a list of
actions, which can be <a href="enum.Action.html#variant.Add" title="variant calimero_storage::interface::Action::Add"><code>Add</code></a>, <a href="enum.Action.html#variant.Delete" title="variant calimero_storage::interface::Action::Delete"><code>Delete</code></a>,
<a href="enum.Action.html#variant.Update" title="variant calimero_storage::interface::Action::Update"><code>Update</code></a>, and <a href="enum.Action.html#variant.Compare" title="variant calimero_storage::interface::Action::Compare"><code>Compare</code></a>. The first
three are the same as propagating the consequences of direct changes, but
the comparison action is a special case that arises when a child entity is
found to differ between the two nodes, whereupon the comparison process
needs to recursively descend into the parts of the subtree found to differ.</p>
<p>The calling code is then responsible for going away and obtaining the
information necessary to carry out the next comparison action if there is
one, as well as relaying the generated action list.</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.ComparisonData.html" title="struct calimero_storage::interface::ComparisonData">Comparison<wbr>Data</a></div><div class="desc docblock-short">Data that is used for comparison between two nodes.</div></li><li><div class="item-name"><a class="struct" href="struct.Interface.html" title="struct calimero_storage::interface::Interface">Interface</a></div><div class="desc docblock-short">The primary interface for the storage system.</div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.Action.html" title="enum calimero_storage::interface::Action">Action</a></div><div class="desc docblock-short">Actions to be taken during synchronisation.</div></li><li><div class="item-name"><a class="enum" href="enum.StorageError.html" title="enum calimero_storage::interface::StorageError">Storage<wbr>Error</a></div><div class="desc docblock-short">Errors that can occur when working with the storage system.</div></li></ul><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.MainInterface.html" title="type calimero_storage::interface::MainInterface">Main<wbr>Interface</a></div><div class="desc docblock-short">Convenient type alias for the main storage system.</div></li></ul></section></div></main></body></html>